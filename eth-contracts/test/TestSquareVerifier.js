// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
const SquareVerifier = artifacts.require('SquareVerifier');
const proof1 = require('../../zokrates/code/square/proof1.json');
const proof2 = require('../../zokrates/code/square/proof2.json');
const proof3 = require('../../zokrates/code/square/proof3.json');
const proof4 = require('../../zokrates/code/square/proof4.json');
const proof5 = require('../../zokrates/code/square/proof5.json');
const proof6 = require('../../zokrates/code/square/proof6.json');
const proof7 = require('../../zokrates/code/square/proof7.json');
const proof8 = require('../../zokrates/code/square/proof8.json');
const proof9 = require('../../zokrates/code/square/proof9.json');
const proof10 = require('../../zokrates/code/square/proof10.json');
const proofs = [
  proof1,
  proof2,
  proof3,
  proof4,
  proof5,
  proof6,
  proof7,
  proof8,
  proof9,
  proof10,
];

contract('SquareVerifier', (accounts) => {
  let contract;

  beforeEach(async () => {
    contract = await SquareVerifier.new({ from: accounts[0] });
    // console.log(JSON.stringify(proof, null, 2));
  });

  for (let i = 0; i < proofs.length; i++) {
    const solutionIndex = i + 1;
    const proof = proofs[i];
    it(`test verification with correct proof${solutionIndex}`, async () => {
      // Test verification with correct proof
      // - use the contents from proof.json generated from zokrates steps
      const result = await contract.verifyTx.call(
        proof.proof.A,
        proof.proof.A_p,
        proof.proof.B,
        proof.proof.B_p,
        proof.proof.C,
        proof.proof.C_p,
        proof.proof.H,
        proof.proof.K,
        proof.input
      );
      // console.log('result = ', JSON.stringify(result, null, 2));
      assert.equal(result, true);
    });

    it(`test verification with incorrect proof${solutionIndex}`, async () => {
      // Test verification with incorrect proof
      const cheatInput = [123, 123];
      const result = await contract.verifyTx.call(
        proof.proof.A,
        proof.proof.A_p,
        proof.proof.B,
        proof.proof.B_p,
        proof.proof.C,
        proof.proof.C_p,
        proof.proof.H,
        proof.proof.K,
        cheatInput
      );
      assert.equal(result, false);
    });
  }
});
